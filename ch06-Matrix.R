########################################################### 
# P. 75, 6.1 뉴튼법 
#-------------------------------------------------------------------------------------- 

f <- function (x) exp(x) - 2         # (1) f(x)를 정의  

( result <- uniroot(f, c(0, 1)) )    # (2) 범위를 c(0,1)로 지정  
                                     #     unitroot()함수 :

result$root                          # 변수 result에서 해를 추출한다   
 

########################################################### 
# P. 76, 6.2 다항식의 해  
#-------------------------------------------------------------------------------------- 

polyroot(c(2, 3, 1))                     # (x+1)(x+2)=0의 해  
round( polyroot(c(2, 3, 1)), digits=3 )  # (x+1)(x+2)=0의 해 
round( polyroot(c(1, 2, 1)), digits=3 )  # (x+1)(x+1)=0의 해  

########################################################### 
# P. 77, 연습문제(1) 
#-------------------------------------------------------------------------------------- 

#-------------------------------------------------------------------------------------- 
# 1. 
#-------------------------------------------------------------------------------------- 

f <- function(x) x^2 - 2*x 
uniroot(f, c(1,3)) 

#-------------------------------------------------------------------------------------- 
# 2. 
#-------------------------------------------------------------------------------------- 

round(polyroot(c(-2, 5, -4, 1)), digits=3) 

########################################################### 
# P. 76, 6.3 함수의 미분   
#-------------------------------------------------------------------------------------- 

f <- expression( a*x^4 ) 
D(f, "x")                                # D(수식, 미분할 변수) 

#-------------------------------------------------------------------------------------- 

DD <- function(expr, name, order = 1) { 
  if(order < 1) stop("'order' must be >= 1") 
  if(order == 1) D(expr, name) 
  else DD(D(expr, name), name, order - 1) 
} 

DD(f, "x", 3)                            # D(수식, 미분할 변수, 미분횟수) 

#-------------------------------------------------------------------------------------- 

f <- deriv(~ x^2, "x", func=T) 
f(-2) 

#-------------------------------------------------------------------------------------- 

g <- deriv(~ x^2*y, c("x","y"), func = TRUE) 
g(2,3) 

#-------------------------------------------------------------------------------------- 

h <- deriv(~ x^2*y*z, c("x","y"), function(x, y, z=4){} ) 
h(3,2) 

########################################################### 
# P. 79, 6.4 수치적분   
#-------------------------------------------------------------------------------------- 

f <- function(x) x^2 
integrate(f, 0, 1) 
integrate(sin, 0, pi) 
integrate(dnorm, -Inf, 1.96)             # dnorm:정규분포의 밀도함수  

#-------------------------------------------------------------------------------------- 

install.packages("cubature",dep=T)       # 설치  
library(cubature)                        # 패키지 호출  

f <- function(x) cos(x)                  # 1변수 함수일 때  
adaptIntegrate(f, 0, pi/2) 

g <- function(x) {                       # 2변수 함수일 때  
  exp(-(x[1]^2+x[2]^2)/2)/(2*pi) 
} 

adaptIntegrate(g, c(-3, -3), c(3, 3))    # 인수는 벡터를 지정  

########################################################### 
# P. 82, 연습문제(2) 
#-------------------------------------------------------------------------------------- 
 
#-------------------------------------------------------------------------------------- 
# 1. 
#-------------------------------------------------------------------------------------- 

f <- deriv(~ x^2 + sin(x), "x", func=T) 
f(0) 

#-------------------------------------------------------------------------------------- 
# 1. 
#-------------------------------------------------------------------------------------- 

f <- function(x) exp(-x^2) 
integrate(f, 0, 1) 
integrate(f, 0, Inf) 
 
########################################################### 
# P. 82, 6.5 행렬의 작성과 기본조작 
#-------------------------------------------------------------------------------------- 

matrix(1:6, nrow=2, ncol=3)              # nrow로 행수, ncol로 열수를 지정  
matrix(1:6, nrow=2, ncol=3, byrow=T)     # matrix(1:6, 2, 3, byrow=T)도 가능  
 
########################################################### 
# P. 83, 6.5.1  행렬 요소 추출 
#-------------------------------------------------------------------------------------- 

( x <- matrix(1:6, nrow=2, ncol=3) ) 

x[1, 2]                                  # 1행 2열의 성분을 표시  
x[c(1,2), 2]                             # 1,2행의 2열 성분을 표시  
x[2, c(1,2)]                             # 2행 1,2열의 성분을 표시  
x[-1, c(T,F,T)]                          # 1행 비표시, 2행 1,3성분지정  
x[2, ]                                   # 2행을 추출  
x[ ,2]                                   # 2열을 추출  
x[ ,2, drop=F]                           # 2행을 행렬의 형태로 추출한다  
x[c(1,2), c(1,3)]                        # 1,2행과 1,3열을 추출  
x[,-c(1, 3)]                             # 1,3열을 제외한 행렬을 만든다  
x[matrix(c(1,2,2,3), 2, 2)]              # 행렬로 지정  
x[1:4]                                   # 행렬이 벡터로 변환되고 나서  

########################################################### 
# P. 84, 6.5.2  행렬의 결합 
#-------------------------------------------------------------------------------------- 

( x <- rbind(c(1,2,3), c(4,5,6)) )       # 행벡터를 주고 행렬 생성  
( x <- cbind(c(1,2,3), c(4,5,6))  )      # 열벡터를 주고 행렬 생성  
( x <- rbind(1:3, c(4, 5, 6), 7:9) )     # 3개의 행벡터를 결합  
( y <- cbind(1:3, c(4, 5, 6), 7:9) )     # 3개의 열벡터를 결합  

########################################################### 
# P. 84, 6.6  행렬의 계산 
#-------------------------------------------------------------------------------------- 

a <- matrix(1:4, 2, 2)                   # 2 * 2 행렬  
b <- matrix(0:3, 2, 2)                   # 2 * 2 행렬  

a + b - a %*% b                          # 합.차.곱  
a * b                                    # 요소별 곱셈  
a %o% b                                  # 외적  
a %x% b                                  # 크로네커 곱 

#-------------------------------------------------------------------------------------- 

a <- matrix(c(1,2,3,4), 2, 2)            # 2 * 2 행렬  

a * (1:2)                                # (1:2) * a도 같은 결과   
1/a 


########################################################### 
# P. 86, 6.6.1 제로 행렬 (Zero Matrix) 
#-------------------------------------------------------------------------------------- 

matrix(0, nrow=2, ncol=3) 

diag(0, 3)                               # 정방행렬일 때는 diag(0,크기) 

########################################################### 
# P. 87, 6.6.2 전치 행렬 (Transpose Matrix) 
#-------------------------------------------------------------------------------------- 

( x <- matrix(c(1,2,3,4) , 2, 2) ) 
t(x) 

########################################################### 
# P. 87, 6.6.3 단위 행렬(Unit Matrix)과 대각 행렬(Diagonal Matrix) 
#-------------------------------------------------------------------------------------- 

( x <- diag(2) )                         # diag(1, ncol=2,  nrow=2), diag(1, 3), 
                                         # diag(rep(1, 3)), diag(c(1,1)) 등도 가능   
diag(1:3) 

#-------------------------------------------------------------------------------------- 

x <- matrix(0, ncol=2, nrow=2)           # 모든 성분이 0인 행렬  
diag(x) <- 1                             # 대각 성분을 1로 한다  
x 

diag(x) <- c(1, 2)                        # 대각 성분을 1,2로 한다  
x 

########################################################### 
# P. 88, 6.6.4 삼각행렬(Triangular Matrix) 
#    대각선 상단부 요소 혹은 하단부 요소가 모두 0인 정방행렬(Square Matrix) 
#-------------------------------------------------------------------------------------- 
#    * 하삼각행렬 만들기 
#      1) 정방행렬을 만든다. 
#      2) upper.tri()를 이용하여 상삼각요소를 0으로 한다. 
# 
#    * 함수 : upper.tri()   <=  x[row{x}>col(x)] <- 0 
#-------------------------------------------------------------------------------------- 

(x <- matrix(1:9,3))    # 임의의 정방핼렬 만들기 
y <- x 

########################################################### 
# 1) 하삼각행력 만들기 : 방법 1 
#-------------------------------------------------------------------------------------- 

y[upper.tri(y)] <- 0    # 상삼각요소를 모두 0으로 대체 
y                       # 하삼각행렬 

#-------------------------------------------------------------------------------------- 
# 다른 방법 
#-------------------------------------------------------------------------------------- 

y <- x 
y[row(x) < col(x)] <- 0 
y 

#-------------------------------------------------------------------------------------- 
# 대각 요소도 0으로 만들기 
#-------------------------------------------------------------------------------------- 

z <- x 
a <- upper.tri(x, diag=TRUE) 
z[a] <- 0              # 대각 요소도 0으로 만들기 
z 

z[upper.tri(z, diag=TRUE)] <- 0  # 대각 요소도 0으로 만들기 
z 

########################################################### 
#    * 상삼각행렬 만들기 
#      1) 정방행렬을 만든다. 
#      2) lower.tri()를 이용하여 하삼각요소를 0으로 한다. 
# 
#    * 함수 : lower.tri()   <=  x[row{x}>col(x)] <- 0 
#-------------------------------------------------------------------------------------- 

(x <- matrix(1:9,3))    # 임의의 정방핼렬 만들기 
y <- x 

########################################################### 
# 2) 상삼각행력 만들기 : 방법 1 
#-------------------------------------------------------------------------------------- 

y[lower.tri(y)] <- 0    # 하삼각요소를 모두 0으로 대체 
y                      # 상삼각행렬 

#-------------------------------------------------------------------------------------- 
# 다른 방법 
#-------------------------------------------------------------------------------------- 

y <- x 
y[row(x) > col(x)] <- 0 
y 

#-------------------------------------------------------------------------------------- 
# 대각 요소도 0으로 만들기 
#-------------------------------------------------------------------------------------- 

z <- x 
a <- lower.tri(x, diag=TRUE) 
z[a] <- 0                         # 대각 요소도 0으로 만들기 
z 

z[lower.tri(z, diag=TRUE)] <- 0   # 대각 요소도 0으로 만들기 
z 
  

########################################################### 
# P. 89, 6.6.5 대칭행렬(Symmetric Matrix) 
#    대각선 상단부 요소와 하단부 요소가 대칭적으로 같은 요소 값을 가짐. 
#--------------------------------------------------------------------------------------#    * 대칭행렬 만들기 
#      => 삼각행렬로 부터 대칭행렬을 생성할 수 있다. 
#-------------------------------------------------------------------------------------- 

#-------------------------------------------------------------------------------------- 
# 삼각행렬 생성 
#-------------------------------------------------------------------------------------- 

(x <- matrix(1:9,3))    # 임의의 정방핼렬 만들기 
x[upper.tri(x)] <- 0    # 상삼각요소를 모두 0으로 대체 
x                       # 하삼각행렬 

#-------------------------------------------------------------------------------------- 
# 삼각행렬의 전치행렬을 생성하여 두 행렬을 더한 다음, 대각 요소를 2로 나눔 
#-------------------------------------------------------------------------------------- 

y <- x + t(x) 
y                        # 두 행렬의 합 

diag(y) <- diag(y) /2 
y                        # 대각 요소만 2로 나눈 결과: 대칭행렬 생성 

########################################################### 
# P.89, 6.6.6 행렬성분의 제곱의 총합 
# 
#    sum(), diag(), %*%의 조합으로 구현 
#-------------------------------------------------------------------------------------- 

#-------------------------------------------------------------------------------------- 

# 임의의 행렬 생성 

#-------------------------------------------------------------------------------------- 

  

x <- array(runif(8), c(2,4)) 

  

#-------------------------------------------------------------------------------------- 

# 행렬요소들의 제곱의 총합 : 방법 1 

#-------------------------------------------------------------------------------------- 

  

sum(x^2) 

  

#-------------------------------------------------------------------------------------- 

# 행렬요소들의 제곱의 총합 : 방법 2 

#-------------------------------------------------------------------------------------- 

  

sum(diag(t(x) %*% x))       # T(x) %*% x 의 대각요소의 합 

  

########################################################### 

# P.89, 6.6.7 연립방정식의 해 

# 

#    A x = b   ===> solve() 

#--------------------------------------------------------------------------------------  

#-------------------------------------------------------------------------------------- 

#   1. 일반적인 연립방정식 풀기 

#-------------------------------------------------------------------------------------- 

#       3y + 6z =  1 

#   x + 4y + 7z =  0 

#  2x + 5y + 9z = -2 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(0,1,2,3,4,5,6,7,9),3,3) 

b <- matrix(c(1,0,-2))  

  

solve(a,b) 

  

########################################################### 

#   2. A가 상삼각행렬의 형태 인 경우 

#      backsolve() 함수 사용 

#-------------------------------------------------------------------------------------- 

#   x + 2y + 3z =  8 

#        y +  z =  4 

#            2z =  2 

#-------------------------------------------------------------------------------------- 

  

r <- rbind(c(1,2,3), 

           c(0,1,1), 

         c(0,0,2)) 

(y <- backsolve(r, x <- c(8,4,2))) 

  

r %*% y 

  

#-------------------------------------------------------------------------------------- 

(y2 <- backsolve(r, x, transpose = TRUE)) 

all(t(r) %*% y2 == x) 

all( y == backsolve(t(r), x, upper = FALSE, transpose = TRUE)) 

all( y2 == backsolve(t(r), x, upper = FALSE, transpose = FALSE)) 

#-------------------------------------------------------------------------------------- 

  

#-------------------------------------------------------------------------------------- 

#   2. A가 하삼각행렬의 형태 인 경우 

#      forwardsolve() 함수 사용 

#-------------------------------------------------------------------------------------- 

 

 

########################################################### 

# P.90, 6.6.8 역행렬 

# 

#    A x = b 에서 b에 A의 차수의 단위행렬을 지정하고,  

#    함수 solve()로 풀면 A의 역행렬을 구할 수 있다. 

#--------------------------------------------------------------------------------------  

#-------------------------------------------------------------------------------------- 

#   방법 1. solve() 이용 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   A = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(0,1,2,3,4,5,6,7,9),3,3) 

solve(a) 

  

#-------------------------------------------------------------------------------------- 

#   방법 2. solve() 이용 

#-------------------------------------------------------------------------------------- 

#       0 3 6         1 0 0 

#   A = 1 4 7     b = 0 1 0 

#       2 5 9         0 0 1 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(0,1,2,3,4,5,6,7,9),3,3) 

b <- matrix(c(1,0,0,0,1,0,0,0,1),3,3) 

solve(a,b) 

  

  

########################################################### 

# P.91, 6.6.9 일반 역행렬 

# 

#      무어 펜로즈형 역행렬 구하기 

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

  

A <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

B <- solve(A)                        # Error 발생 (?) 

  

install.packages("MASS") 

library(MASS) 

  

B <- ginv(A) 

B 

 

 

########################################################### 

# P.90, 6.6.10 크로스 곱 : 행렬의 곱하기 

# 

#    행렬 A와 B의 크로스 곱  

#       crossprod()  

#    or t(A)%*%B 로 구할 수 있다. 

#     

#       t(A)%*%A  (t(A)는 A의 전치 행렬)  

#-------------------------------------------------------------------------------------- 

#         1 2 3 

#   A = 4 5 6 

#         7 8 9 

#-------------------------------------------------------------------------------------- 

#         0 3 6 

#   B = 1 4 7 

#         2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

crossprod(a,b) 

crossprod(a) 

crossprod(b) 

 

 

########################################################### 

# P.92, 6.6.11 고유값과 고유벡터 (Eigen Value, Eigen Vector) 

# 

#    함수 eigen()으로 구할 수 있다. 

#     

#    [참고자료] https://wikidocs.net/4050 

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

eigen(a) 

eigen(b) 

 

 

############################################################## 

# P.92, 6.6.12 QR 분해 (행렬의 랭크) 

#-------------------------------------------------------------------------------------- 

# 

#    QR 분해는 통게적 기법 중에서 중요한 역할을 한다.  

#    Ax = b를 푸는데 사용할 수 있다. 

#    함수 qr()을 사용한다. 

#    상삼각행혈 부분이 R(상삼각 행렬), 하삼각 부분은 Q(직교 행렬)에 관한 정보를 포함. 

# 

#    행렬 분해의 일종으로 임의의 행렬을 ['직교행렬'과 '상삼각행렬'의 곱]으로 분해하는 방법이다 

# 

#    A = Q R 

#        Q : 직교 행렬, R : 상삼각 행혈 

#    [참고자료] https://ko.wikipedia.org/wiki/QR_%EB%B6%84%ED%95%B4 

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

qr(a) 

 

 

 

############################################################## 

# P.96, 6.6.15 행렬의 제곱근 

# 

#    함수 svd()을 사용해서 구할 수 있다. 

# 

#    B B = A일 때, B를 A행렬의 제곱근이라고 한다. 

# 

#    [참고자료] https://ko.wikipedia.org/wiki/%EC%A0%9C%EA%B3%B1%EA%B7%BC_%ED%96%89%EB%A0%AC 

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

  

u_a <- svd(a)$u 

v_a <- svd(a)$v 

d_a <- diag(sqrt(svd(a)$d)) 

  

(root_a <- u_a %*% d_a %*% t(v_a)) 

  

#-------------------------------------------------------------------------------------- 

  

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

u_b <- svd(b)$u 

v_b <- svd(b)$v 

d_b <- diag(sqrt(svd(b)$d)) 

  

(root_b <- u_b %*% d_b %*% t(v_b)) 

 

 

 

############################################################## 

# P.97, 6.6.16 1) 정방행렬의 n승, 지수승 

# 

#    정방행렬 A에 대한 제곱 A^2은 성분별로 제곱한 행렬을 줄 뿐, 행렬 자체의 멱승 A %*% A는 주지 않는다. 

# 

#    A의 멱승 A^n을 계산하려면 A의 고유값 분해 A = V %*% D %*% t(V)를 이용해서 

#    A^n = V %*% (D^n) %*% t(V)를 계산한다.  (D는 대각행렬) 

#     

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

############################################################## 

# matpow() 함수 정의 

#-------------------------------------------------------------------------------------- 

  

matpow <- function(x, pow=2) { 

    y <- eigen(x) 

    y$vectors %*% diag((y$values)^pow) %*% t(y$vectors) 

} 

  

#-------------------------------------------------------------------------------------- 

 

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

matpow(a) 

  

############################################################### matpow() 함수 정의 

#-------------------------------------------------------------------------------------- 

 

matpow <- function(x, pow=n) { 

    y <- eigen(x) 

    y$vectors %*% diag((y$values)^pow) %*% t(y$vectors) 

} 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

matpow(a,2) 

matpow(a,4) 

  

  

############################################################## 

# P.97, 6.6.16 2) 정방행렬의 지수승 

############################################################## 

  

############################################################## 

# matexp() 함수 정의 

#-------------------------------------------------------------------------------------- 

 

matexp <- function(x) { 

    y <- eigen(x) 

    y$vectors %*% diag(exp(y$values)) %*% t(y$vectors) 

} 

#-------------------------------------------------------------------------------------- 

  

matexp(a) 

matexp(b) 

  

  

############################################################## 

# P.98, 6.6.17 행렬식(Determinant) 

# 

#    1) det() 함수 이용 

# 

#    2) prod(svd(A)$d) = |det(A)| 

# 

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

det(a) 

prod(svd(a)$d) 

  

det(b) 

prod(svd(b)$d) 

 

 

############################################################## 

# P.98, 6.7.1 R에서 행렬이란 

# 

#    * 행과 열이 있는 2차원 배열 

#      일반적인 행렬은 각 요소가 수치 데이터. 

# 

#    * R에서의 행렬은 2차원 배열로, 논리값이나 문자열 등을 요소로 할 수 있다. 

# 

#    * 행렬 만드기 : matrix() 또는 array() 함수 이용 

# 

#-------------------------------------------------------------------------------------- 

 

  

#-------------------------------------------------------------------------------------- 

#       1 2 3 

#   A = 4 5 6 

#       7 8 9 

#-------------------------------------------------------------------------------------- 

#       0 3 6 

#   B = 1 4 7 

#       2 5 9 

#-------------------------------------------------------------------------------------- 

  

a <- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) 

b <- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) 

  

  

  

############################################################### P.99, 6.7.2 행렬의 크기 

# 

#    1) 행렬은 dim 속성을 가짐. (행의 수, 열의 수)라는 길이 2인 정수 벡터 형태 

#       ==> dim(), nrow(), ncol() 

#-------------------------------------------------------------------------------------- 

 

dim(a) 

nrow(a) 

ncol(a) 

  

#-------------------------------------------------------------------------------------- 

# P.98, 6.7.2 행렬의 크기 

# 

#    2) 행렬의 크기 변경 :  

#       ==> matrix() 사용하는 방법 

#       ==> dim 속성 사용하는 방법. 강제 변경 

#       dim 속성을 사용했을 때의 변경결과는 matrix()를 사용해서 행렬 크기를 변경했을 때와 같다. 

#-------------------------------------------------------------------------------------- 

dim(a) <- c(3,2)                                   # Error 메시지 

  

matrix(as.vector(a), nrow=2, ncol=6) 

  

matrix(b, nrow=2, ncol=5) 

matrix(b, nrow=2, ncol=6) 

matrix(b, nrow=2, ncol=7) 

matrix(b, nrow=2, ncol=8) 

matrix(b, nrow=2, ncol=9) 

  

############################################################## 

# P.99, 6.7.3 행과 열의 라벨 

#    1) 행렬에 속성 이름(라벨)을 부여할 수 있다.  

#       ==> names(), rownames(), colnames() 사용 

#-------------------------------------------------------------------------------------- 

  

rownames(a) <- c("row #1", "row #2", "row #3") 

colnames(a) <- c("col #1", "col #2", "col #3") 

a 

a["row #1",] 

a[,"col #2"] 

  

rownames(b) <- c("1행", "2행", "3행") 

colnames(b) <- c("1열", "2열", "3열") 

b 

  

#-------------------------------------------------------------------------------------- 

# P.99, 6.7.3 행과 열의 라벨 

#    2) 행과 열의 어느 한쪽의 라벨이 필요 없으면, 

#               dimnames 속성에서 대응하는 요소를 NULL로 하면 된다 

#       양쪽 라벨 모드 필요 없으면, dimnames 속성 자체를 제거하면 된다. 

#-------------------------------------------------------------------------------------- 

  

rownames(b) <- NULL        # 행 라벨 없애기 

b 

colnames(b) <- NULL        # 열 라벨 없애기 

b 

  

dimnames(a) <- NULL        # 행과 열의 라벨 모두 없에기 

a 

 

############################################################## 

# P.99, 6.7.3 행과 열의 라벨 

#    3) 벡터 오브젝트명을 사용해서 행렬로 만들 때 

#-------------------------------------------------------------------------------------- 

  

x <- 1:3 

y <- 4:6 

matname <- c("x","y")        # x, y의 오브젝트명으로 된 문자 벡터 

sapply(matname, get)        # x, y를 행렬로 만든다. (오브젝트명 = 행렬명) 

  

  

# 함수의 사용방법 확인 방법 : 1) ?sapply(), 2) help (sapply), 3) Google 검색 

  

  

############################################################## 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    1) 함수 matrix()의 인수 nrow와 ncol 중 한쪽만 지정하면 행렬 크기에 의해 

#       다른 한쪽이 자동으로 결정된다. 

#       이때, matrix()에 지정한 요소가 행렬의 크기에 모자라면 

#            최초의 요소부터 순환하여 보충된다. 

#-------------------------------------------------------------------------------------- 

 

 

  

x <- matrix(1:6, nrow=3) 

y <- matrix(1:6, ncol=3) 

  

#-------------------------------------------------------------------------------------- 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    2) 행렬 작성에 사용되는 벡터의 요소가 충분하지 않으면 

#       요소가 반복해서 사용된다. 

#-------------------------------------------------------------------------------------- 

 

  

(a <- matrix(1, nrow=2, ncol=3)) 

(b <- matrix(1:2, nrow=2, ncol=3)) 

(c <- matrix(1:3, nrow=3, ncol=3, byrow=T)) 

  

  

#-------------------------------------------------------------------------------------- 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    3) nrow, ncol 과 관련된 함수로는 행렬을 인수로 지정하면, 

#       행 번호와 열 번호로 채워진 같은 크기의 행렬을 반환하는  

#       row()와 col()이라는 함수도 있다. 

#-------------------------------------------------------------------------------------- 

 

(x <- matrix(1:6, nrow=2, ncol=3)) 

row(x) 

col(x) 

  

#-------------------------------------------------------------------------------------- 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    4) 요소를 치환한 결과는 될 수 있는 한 원래 행렬 형태를 보존하려는 작용이 있다. 

#       요소를 치환할 때 다소 형이 일치하지 않아도 자동으로 조절된다. 

#-------------------------------------------------------------------------------------- 

 

(x <- matrix(1:12, nrow=3, ncol=4)) 

x[1:2, 3:4] <- c(333,555,777,999) 

x 

  

#-------------------------------------------------------------------------------------- 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    5) 어떤 조건을 만족하는 행렬 요소의 우치(번호)를 추출할 때는  

#       함수 which()를 인수 arr.ind=TRUE 로 지정해서 사용한다. 

#       arr.ind=FALSE로 하면, 행렬을 벡터화하고 요소의 번호벡터를 반환한다. 

# 

#     예) 요소가 2의 배수인 행렬의 위치(번호)를 추출한다. 

#-------------------------------------------------------------------------------------- 

 

(x <- matrix(1:12, nrow=3, ncol=4)) 

(y <- which(x%%2==0, arr.ind=TRUE))  

(y <- which(x%%2==0, arr.ind=FALSE))  

  

(x <- matrix(c(5,7,2,8,5,2,3,4,5), c(3,3))) 

(y <- which(x%%2==0, arr.ind=TRUE))       #  

(y <- which(x%%2==0, arr.ind=FALSE))    # 행렬을 벡터화 하고, 2의 배수 요소위치를 출력 3,4,6,8 

   

#-------------------------------------------------------------------------------------- 

# P.100, 6.7.4 행렬 요소의 보충, 치환, 추출 

#    6) 어떤 조건을 만족하는 행렬의 해당 장소를 마킹하는 방법도 있다. 

#-------------------------------------------------------------------------------------- 

 

  

x[x%%2==0]                # 2의 배수 요소를 순서대로 출력 

  

x[x%%2==0] <- "*"            # 2의 배수 요소는 '*'로 마킹하고 출력 

x 

  

  

############################################################## 

# P.103, 6.7.5 행(렬)에 대한 연산과 조작 

#    1) 함수 apply()를 사용하면 행렬의 열(혹은 행)의 합을 요소로 하는 벡터를 만들 수 있다. 

#-------------------------------------------------------------------------------------- 

  

(x <- matrix(c(5,7,2,8,5,2,3,4,5), c(3,3))) 

apply(x,2, sum)            # 열의 합 -> 함수 colSums(x)와 같다. 

apply(x,1, sum)            # 행의 합 -> 함수 rowSums(x)와 같다. 

  

  

#-------------------------------------------------------------------------------------- 

# P.103, 6.7.5 행(렬)에 대한 연산과 조작 

#    2) 행렬의 열(혹은 행) 전체에 함수를 적용할 수 있다. 

#-------------------------------------------------------------------------------------- 

  

(x <- matrix(c(5,7,2,8,5,2,3,4,5), c(3,3))) 

apply(x,1,max)            # 각 행의 최대값을 구한다. 

apply(x,2,max)            # 각 열의 최대값을 구한다. 

  

############################################################## 

# P.103, 6.7.6 행렬의 특정 행(열)에 관해 정렬한다. 

#    1) 행렬을 어떤 행 또는 열에 관해 정렬할 때는 함수 order()를 사용한다. 

#    2) 행렬의 각 행렬 최대 요소의 위치를 구할 때는 함수 max.col()을 사용한다. 

#-------------------------------------------------------------------------------------- 

  

(x <- matrix(runif(16), 4,4))        # 2x2 행렬 생성 

order(x[,2])                # 2열의 순서를 출력 

x[order(x[,2]),]                # 2열의 수치가 오름차순이 되게 정렬 

x[,order(x[1,])]                # 1행의 수치가 오름차순이 되게 정렬 

max.col(x)                    # 행렬의 각 행별 최대 요소의 위치 

  

 ############################################################## 

# P.104, 6.7.7 팁 

# 

#    함수 image()를 사용해서 행렬의 이미지를 그림으로 표현 

#-------------------------------------------------------------------------------------- 

  

x <- matrix(rep(0:1,81), 9,9) 

image(x, col=c(5,9)) 

  

 ############################################################## 

# P.104, 연습문제 

# 

#    1. 행렬 A=(1 2 

#              0 1)에 대해, A^2, A^3 을 구하라. 

# 

#    2. 1의 행렬 A에 대해 행렬식과 역행렬을 구하다. 

# 

#    3. 연립방정식  

#                x + 2y =  4 

#               2x -  y =  3 

#-------------------------------------------------------------------------------------- 

# 1. 

( a <- matrix(c(1,0,2,1), 2,2)) 

  

(b <- a %*% a) 

(c <- b %*% a) 

  

# 2. 

#-------------------------------------------------------------------------------------- 

# 행렬식 

( a<- matrix(c(1,0,2,1), 2,2)) 

det(a) 

 

#-------------------------------------------------------------------------------------- 

# 역행렬 

library(MASS) 

ginv(a) 

#-------------------------------------------------------------------------------------- 

  

# 3. 

 

(a <- matrix(c(1,2,2,-1), 2, 2)) 

(b <- c(4,3)) 

solve(a,b) 