############################################################### 
#  p. 261   12.1 연산자와 인덱스  
#------------------------------------------------------------------------------------------- 
 
a <- rnorm(1)               # 정규난수를 하나 발생 ­( a =  0.468251 ) 
b <- rnorm(1)               # ­정규난수를 하나 발생 ( b = -0.4981989) 
if ((a > 0) && (b > 0)) {   # a > 0 이고 b > 0 이라는 조건식  
  c <- a*b                  # a * b = -0.2332821 
} else c <- -a*b            # c에는 a * b 의 절댓값 0.2332821가  
c                           # 대입되어 있다  
 
a <- rnorm(1)               # ­정규난수를 하나 발생 ( a =  0.468251 ) 
b <- rnorm(1)               # ­정규난수를 하나 발생 ( b = -0.4981989) 
if ((a < 0) || (b < 0)) {   # a < 0 또는 b < 0 라는 조건식  
  c <- -a*b                 # a * b = -0.2332821 
} else c <- a*b             # c에는 a * b의 절댓값 0.2332821가  
c                           # 대입되어 있다  
 
x <- matrix(1:4, 2, 2) 
x[2,2] 
 
#------------------------------------------------------------------------------------------- 
#  p. 263   12.2 복합식 
#------------------------------------------------------------------------------------------- 
 
#------------------------------------------------------------------------------------------- 
#  p. 264   12.3 조건 분기 
#------------------------------------------------------------------------------------------- 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 264   12.3.1 if ~ else 문 
#------------------------------------------------------------------------------------------- 
 
a <- rnorm(1) 
if (a >= 0) { 
  if (a == 0) b <- "zero" 
  else b <- a 
} 
else b <- -a                # 이 다음 오류가 나온다  
 
{  
  if (a >= 0) {  
    if (a == 0) b <- "zero"  
    else b <- a 
  }  
  else b <- -a              # 오류는 나지 않는다  
} 
 
myfunc <- function(a) { 
  if (a >= 0) { 
    if (a == 0) b <- "zero" 
    else b <- a             # 오류는 나지 않는다  
  } 
  else b <- -a              # 오류는 나지 않는다  
  return(c(a,b)) 
}  
 
 
x <- -3 
if (x<-2) print(x)          # x<-2는 x에 -2를 대입한다는 의미 :   
 
 
if (a < 0) {                # 일반 프롬프트 내라면  
  print(0) 
} else if (a < 1) { 
  print(1) 
} else print(2) 
myfunc <- function(a) {     # 함수 정의 내라면  
  if (a < 0)  print(0) 
  else if (a < 1) print(1) 
  else print(2) 
} 
 
x <- c(6:-4) 
sqrt(x) 
sqrt(ifelse(x >= 0, x, NA)) 
 
#------------------------------------------------------------------------------------------- 
#  p. 266   12.3.2 switch 문 
#------------------------------------------------------------------------------------------- 
 
a <- 1 
switch(a, 
  "1" = print("one"), 
  "2" = print("two"), 
  print("?") 
) 
 
a <- 2 
switch(a, 
  print("one"), 
  print("two") 
) 
 
#------------------------------------------------------------------------------------------- 
#  p. 268   12.4 반복문 
#------------------------------------------------------------------------------------------- 
 
#------------------------------------------------------------------------------------------- 
#  p. 268   12.4.1 for 문 
#------------------------------------------------------------------------------------------- 
 
x <- 0 
for (i in 1:5) { 
  x <- x + 1 
} 
 
xx <- 1:5 
for (i in x) x <- c(x, i) 
xfor (i in 1:5) x <- c(x, i) 
x 

x <- 0 
y <- matrix(1:10, 2, 5) 
for (i in y) x <- x+1 
x 
 
par(mfrow=c(2,2)) 
x <- list(1:6, sin, runif(6), dnorm) 
for (i in x) plot(i, xlim=c(0,2*pi)) 
 
#------------------------------------------------------------------------------------------- 
#  p. 269   12.4.2 while 문 
#------------------------------------------------------------------------------------------- 
 
x <- 0 
while (x <= 5) { 
  x <- x + 1 
} 
x 
 
#------------------------------------------------------------------------------------------- 
#  p. 270   12.4.3 breakt 문: 반복문에서 탈출 
#------------------------------------------------------------------------------------------- 
 
x <- 0 
for (i in 1:5) { 
  x <- x + 1 
  if (x == 3) break                       # x가 3이 되면 for문을 벗어난다  
} 
x 
 
#------------------------------------------------------------------------------------------- 
#  p. 270   12.4.4 next 문: 강제적으로 다음 반복으로 이동 
#------------------------------------------------------------------------------------------- 
 
x <- 0 
for (i in 1:5) { 
  next                                    # x에 1을 더하기 전에 다음 반복이 시작  
  x <- x + 1 
} 
x 
 
#------------------------------------------------------------------------------------------- 
#  p. 271   12.4.5 repeat 문 
#------------------------------------------------------------------------------------------- 
 
x <- 0 
repeat { 
  if (x <= 5) x <- x+1 
  else        break                       # x > 5이면 repeat문을 벗어난다  
} 
x 
 
#------------------------------------------------------------------------------------------- 
#  p. 272   12.5 함수의 정의 
#------------------------------------------------------------------------------------------- 
 
sin <- function(x) ifelse(x > 0, 1, -1)   # 경고는 나오지 않는다! 
sin(1) 
rm(sin)                                   # 오브젝트 제거  
sin(1) 
 
#------------------------------------------------------------------------------------------- 
#  p. 272   12.5.1 새로운 함수 정의 
#------------------------------------------------------------------------------------------- 
 
mysquare <- function(x) x^2 
mysquare(2) 
 
mysquare <- function(x) { 
  return( x^2 )                           # 위와 같은 함수 정의  
} 
mysquare(2) 
 
#------------------------------------------------------------------------------------------- 
#  p. 273   12.5.2 새로운 연산자의 정의 
#------------------------------------------------------------------------------------------- 
 
"%+=%" <- function(x, y) { x <<- x + y } 
"%-=%" <- function(x, y) { x <<- x - y } 
x <- 0;  (x %+=% 3) 
(x %-=% 2) 
 
#------------------------------------------------------------------------------------------- 
#  p. 272   12.5.3 함수의 반환값 
#------------------------------------------------------------------------------------------- 
 
mysquare <- function(x) { 
  if (!is.numeric(x)) return(NA)          # 수치가 아니면 NA를 반환  
  return(x^2)                             # 수치면 x^2를 반환  
} 
 
mysquare <- function(x) { 
  if (!is.numeric(x)) return(NA)          # 수치가 아니면 NA를 반환  
  x^2                                     # 수치면 x^2를 반환  
} 
 
mysquare <- function(x) { 
  y <- x^2 
  return(x, y)                            # return에 복수의 인수를 지정하면 경고가 나온다  
} 
mysquare(2) 
 
mysquare <- function(x) { 
  y <- x^2 
  return( list(x, y) )                    # 경고가 나오지 않는다  
} 
mysquare(2) 
 
mysquare <- function(x) { 
  y <- x^2 
  return( list(input=x, output=y) ) 
} 
mysquare(2) 
 
mysquare <- function(x) { 
  return( function (y){ y^x } ) 
} 
result <- mysquare(2)             # result(y)는 함수 y^2 
result(3) 
 
#------------------------------------------------------------------------------------------- 
#  p. 275   12.5.4 화면에 계산 결과(반환값)를 표시하지 않는다. 
#------------------------------------------------------------------------------------------- 
 
mysquare <- function(x) { 
  return( invisible(x^2) ) 
} 
mysquare(3)                       # 아무것도 표시되지 않는다  
 
y <- mysquare(3)                  # 변수에 대입하고서야 비로소 표시할 수 있다  
y 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 276   12.5.5 오류와 경고 표시 
#------------------------------------------------------------------------------------------- 
 
mysquare <- function(x) { 
  if (!is.numeric(x)) stop("not numeric !") 
  return(x^2)                     # 수치면 x^2를 반환  
} 
mysquare("a") 
 
 
mysquare <- function(x) { 
  if (!is.numeric(x)) { 
    warning("not numeric !")      # 수치가 아니면 경고를 보내고  
    return(NA)                    # NA를 반환  
  } 
  return(x^2)                     # 수치면 x^2를 반환  
} 
mysquare("a") 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 276   12.5.6 오류가 일어나도 작업을 계속한다. 
#------------------------------------------------------------------------------------------- 
 
mysquare <- function(x) { 
  if (x%%2 == 1) stop("error !")  # 홀수면 오류를   
    return(x^2)                   # 짝수면 x^2를 반환   
    } 
result <- lapply(1:2, function(x){ try(mysquare(x), TRUE) } ) 
result 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 277   12.5.7 로컬변수와 영속대입 <<-  
#------------------------------------------------------------------------------------------- 
 
x <- 10                           # 전역 변수  x 
myfunc <- function(y) {           # y는 인수(형식 파라미터라고 한다) 
  x <- y + 999                    # x는 함수 myfunc() 안의 지역 변수  
  return(x)                       # 인수도 로컬 변수도 아닌 변수는  
}                                 # 자유변수라고 한다  
xmyfunc(1) 
x                                 # 영향이 없는지 확인한다  
 
 
x <- 10                           # 전역 변수  x 
myfunc <- function () { 
  x <- 777                        # 함수 myfunc() 안의 지역 변수 x 
  x <<- 99                        # 전역 변수 x에 99를 대입 
  print(x)                        # 지역 변수 x의 값을 표시  
} 
myfunc() 
x                                 # 함수 myfunc() 내에서 전역 변수 x의 값을  
 
x <- 10 
myfunc <- function () { 
  x <- c(1, 2)                    # 이 문을  x <- 1:3으로 한 경우와  
  x[2] <<- 0                      # 이 문을 assign(x[2], 2, env=.GlobalEnv)으로 한 
  print(x)                        # 경우의 동작의 차이를 비교할 것을 권장한다  
} 

myfunc()                          # 지역 변수 x의 값(값이 변경되어 있다) 
x                                 # 전역 변수 x의 값(어느 샌가 벡터로...)  
 
 
#------------------------------------------------------------------------------------------- 
#  p. 279   12.5.8 함수 안에서 함수 정의 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(x) { 
  y <- 2 
  mysquare <- function(a, b) { 
    a^b 
  } 
  mysquare(x, y) 
} 
myfunc(3) 
 
#------------------------------------------------------------------------------------------- 
#  p. 279   12.5.9 함수에 관한 정보를 본다. 
#------------------------------------------------------------------------------------------- 
 
f <- function(x) x^2                      # 함수 정의  
f                                         # 함수 정의식을 확인: body(f)로도 된다  
formals(f)                                # 함수 f의 형식적 인수를 조사한다  
formals(f) <- alist(x=, y=2)              # 형식적 인수 x,y를 설정  
f                                         # f의 정의를 확인  
formals(f) <- alist(x = , y = 2, ... = )  # 기타 인수 .. 
f 
 
methods(mean) 
 
mean.default 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 281   12.5.10 함수 종료 시의 처리 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(x) { 
  oldpar <- par()                         # 처음에 작도 파라미터를 저장한다  
  par(col="red") 
  plot(x) 
  par(oldpar)                             # 마지막에 작도 파라미터를 원래도로 되돌린다  
}  

myfunc(1:10) 
 
 
myfunc <- function(x) { 
  oldpar <- par()                         # 처음에 작도 파라미터를 저장한다  
  on.exit(par(oldpar))                    # 함수 종료시에 par(oldpar)를 실행한다  
  par(col="red") 
  plot(x) 
} 
myfunc(1:10) 
 
on.exit(par(oldpar), add=T)               # 종료 처리: par(oldpar)를 추가  
on.exit(par(oldpar), add=F)               # 종료 처리:  par(oldpar)만 실행   
on.exit()                                 # 함수 종료 시의 처리를 무효로 한다  
 
 
#------------------------------------------------------------------------------------------- 
#  p. 282   12.6 인수 
#------------------------------------------------------------------------------------------- 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 282   12.6.1 인수 검사 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function (n) ifelse(n==0, 1, prod(1:n)) 
myfunc(0) 
myfunc(5) 
 
 
myprod <- function(n) { 
  if   (n != floor(n) || n < 0) return() 
  else return(gamma(n+1))                
} 
myprod(3) 
myprod(-1) 
 
#------------------------------------------------------------------------------------------- 
#  p. 283   12.6.2 인수의 생략 
#------------------------------------------------------------------------------------------- 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 283   (1) 인수의 선언부에서 지정하는 방법 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(x, y=1) { 
  return(x*y)           # 두 인수의 곱셈을 한다   
}
myfunc(2,5) 
myfunc(2)               # 인수를 하나로 하면 그대로 반환하다  
 
myfunc <- function(x, y=x^2) { 
  return(x*y) 
} 
myfunc(2,5) 
myfunc(2) 
 
myfunc <- function(x=2*y, y=x^2) { 
  return(x*y) 
}  
myfunc(2) 
myfunc() 
 
#------------------------------------------------------------------------------------------- 
#  p. 284   (2) 함수 missing()을 사용하는 방법 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(x, y) { 
  if (missing(y)) return(x) 
  else return(x*y) 
} 
myfunc(2,5) 
myfunc(2) 
 
myfunc <- function(x, y=1) { 
  if (missing(y)) warning("y isn't inputted.") 
  return(x*y) 
} 
myfunc(3,2) 
myfunc(2) 
 
#------------------------------------------------------------------------------------------- 
#  p. 285   (3) 임의 개의 인수를 받는다. 
#------------------------------------------------------------------------------------------- 
 
myfunc1 <- function(x, ...) { 
  xlabel <- deparse(substitute(x))  # 제1인수의 변수명을 얻는다  
    plot(x, xlab=xlabel, ...)         # plot()에도 ... 를 부여한다  
} 
x <- 1:10 
myfunc1(x, ylab="y") 
myfunc2 <- function(...) { 
  args <- list(...)                 # 인수의 리스트  
  return(args)                      # 인수의 리스트를 반환한다  
}  
myfunc2(1:10, "title") 
 
myfunc <- function(... , y = 1) { 
  2*y 
} 
 
#------------------------------------------------------------------------------------------- 
#  p. 286   (4) 인수로 함수를 지정한다. 
#------------------------------------------------------------------------------------------- 
 
( x <- matrix(1:6, 2) ) 
apply(x, 2, sum) 
 
( x <- matrix(1:6, 2) ) 
apply(x, 2, function(x) { x+700 } ) 
 
myfunc <- function(x, f) f(x) 
myfunc(2, sqrt) 
myfunc <- function(x, f=log) f(x)  
myfunc(2)                        # 기본 함수 log가 사용된다  
 
myfunc <- function(x, f=log) f(x)  
x <- 1 
Myfunc(x, f=functon(y) 1  / (1 + exp(y)))  
 
myfunc1 <- function(x, alpha=0)    mean(x, alpha) 
myfunc2 <- function(x, alpha, fun) fun(x, alpha) 
myfunc2(c(0,1,4,9,16), 0.4, myfunc1) 
 
#------------------------------------------------------------------------------------------- 
#  p. 288   12.6.5 인수의 매칭과 선택 
#------------------------------------------------------------------------------------------- 
 
plot(sin, xlab = "x-title")      # x축에 타이틀을 붙인다   
plot(sin, xla  = "x-title")      # "xla"로도 "xlab"이라고 알 수 있다  
plot(sin, xl   = "x-title")      # "xl"로는 "xlab"이라고 알 수 없다  
 
 
myfunc <- function(a, b, do = c("sum", "minus", "multi", "div")) { 
  do <- match.arg(do) 
  switch(do, sum   = a+b,        # do (match.arg의 반환값)  
             minus = a-b,        # 의 결과로 조건분기  
             multi = a*b, 
             div   = a/b) 
} 
myfunc(3, 2, "minus") 
myfunc(3, 2, "mi")               # 인수 : "mi"로도 "minus"라고 알 수 있다  
myfunc(3, 2, "m")                # "m"으로는 "minus"라고 알 수 없다 ... 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 289   12.7 재귀호출 
#------------------------------------------------------------------------------------------- 

myfunc <- function(n) { 
  if (n <= 1) return(1) 
  else        return( n * myfunc(n-1) ) 
} 
myfunc(5) 
 
myfunc <- function(n) { 
  if (n <= 1) return(1) 
  else        return( n * Recall(n-1) ) 
} 
myfunc(10) 
 
#------------------------------------------------------------------------------------------- 
#  p. 289   12.8 디버그 
#------------------------------------------------------------------------------------------- 
 
#------------------------------------------------------------------------------------------- 
#  p. 290   12.8.1 실행 중에 변수의 값을 조사한다.: cat(), print() #------------------------------------------------------------------------------------------- 
 
myfunc <- function(z) { 
  x <- rnorm(1) 
  y <- rnorm(1) 
  cat("x =", x, "\n")                # 현재 x 값을 조사한다  
  cat("y =", y, "\n")                # 현재 y 값을 조사한다  
  if ((x < 0) || (y < 0)) s <- -x*y 
  else                    s <-  x*y 
  cat("s =", s, "\n")                # 현재 s 값을 조사한다  
  return(s*z) 
}  
 
myfunc(10) 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 290   12.8.2 평가 도중에 변수를 조사한다: browser() 
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(z) { 
  x <- rnorm(1) 
  y <- rnorm(1) 
  if ((x < 0) || (y < 0)) s <- -x*y 
  else                    s <-  x*y 
  browser()                          # 현재 상황을 조사한다  
  return(s*z) 
}  
 
myfunc(10) 
x 
y 
x + y 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 292   12.8.3 디버그 모드에 들어간다: debug() 
#------------------------------------------------------------------------------------------- 
 
debug(myfunc) 
myfunc(10) 

#------------------------------------------------------------------------------------------- 
#  p. 293   12.8.4 함수 호출을 추적한다: trace() 
#------------------------------------------------------------------------------------------- 
 
trace(myfunc, browser, exit = browser) 
myfunc(10) 
 
trace(myfunc, recover) 
 
untrace("myfunc") 
untrace(c("func", "myfunc"))  
 
 
#------------------------------------------------------------------------------------------- 
#  p. 294   12.9 보충학습
#------------------------------------------------------------------------------------------- 
 
#------------------------------------------------------------------------------------------- 
#  p. 294   12.9.1 파일에 저장된 함수 정의를 불러온다.
#------------------------------------------------------------------------------------------- 
 
source("C:/dis.R") 
 
#------------------------------------------------------------------------------------------- 
#  p. 295   12.9.2 함수를 저장해서 재사용할 수 있게 한다.
#------------------------------------------------------------------------------------------- 
 
myfunc <- function(x) x^2 
save(myfunc, file="myfunc.Rdata") 
load("myfunc.Rdata") 
 
#------------------------------------------------------------------------------------------- 
#  p. 295   12.9.3 연속된 변수를 만든다.
#------------------------------------------------------------------------------------------- 
 
for (i in 1:10) { 
  assign(paste("x", i, sep=""), i)  # 변수 xi에 i를 대입  
} 
x1 
x2 
 
#------------------------------------------------------------------------------------------- 
#  p. 296   12.9.4 수치 벡터의 대화식 입력: readline() 
------------------------------------------------------------------------------------------- 
 
fun <- function() { 
  ANSWER <- readline("Are you a satisfied R user? ") 
  if (substr(ANSWER, 1, 1) == "n") 
    cat("This is impossible.  YOU LIED!\n") 
  else 
    cat("I knew it.\n") 
} 
fun() 
 
 
myfunc <- function () { 
  x <- readline("데이터 입력 : ") 
  unlist(strsplit(x, " ")) 
} 
y <- myfunc() 
y 
 
x <- 1:10 
y <- get(readline()) 
y 
 
#------------------------------------------------------------------------------------------- 
#  p. 297   12.9.5 메뉴에 의한 선택: menu() 
#------------------------------------------------------------------------------------------- 
 
switch(menu(c("List letters", "List LETTERS")) + 1, 
       cat("Nothing done\n"), letters, LETTERS) 
 
 
#------------------------------------------------------------------------------------------- 
#  p. 297   12.9.6 객체 지향 프로그래밍
#------------------------------------------------------------------------------------------- 
 
#------------------------------------------------------------------------------------------- 
#  p. 298   12.9.7 일괄 처리
#------------------------------------------------------------------------------------------- 
 
system(paste('"C:/Program Files/Mozilla Firefox/firefox.exe"', 
             '-url cran.r-project.org'), wait = FALSE) 
 
#       shell("명령") 
#      shlell.exe("파일") 